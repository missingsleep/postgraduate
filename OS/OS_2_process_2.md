### 2.3.5 经典同步问题

#### #1生产者-消费者问题
系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个数据放入缓冲区，消费者每次从缓冲区取出一个产品并使用。  
限制条件：
1. 生产者，消费者共享一个初始为空，大小为n的缓冲区。
2. 只有缓冲区没满时，生产者才能把数据放入缓冲区，否则必须等待。
3. 只有缓冲区不空时，消费者才能取出数据，否则必须等待。
4. 缓冲区是临界资源，各进程必须互斥地访问。
```c
semaphore mutex =1;  //互斥信号量，实现对缓冲区互斥。
semaphore empty =n;  // 同步信号量，确定缓冲区空间
semaphore full; =0;  //同步信号量，确定产品数量。

producer(){
  while (1) {
    //生产产品
    P(empty);
    P(mutex);
    //把产品放入缓冲区
    V(mutex);
    V(full)；
  }
}
consumer(){
  while(1){
    P(full);
    P(mutex);
    //从缓冲区取出一个产品
    V(mutex);
    V(empty);
    //使用产品
  }
}
```
如果要进行互斥操作，需要在同一进程内进行一对P，V操作。  
如果要进行同步操作，需要在两个进程实现同步关系，一个执行P，一个执行V。  
**如果调换P(empty)和P（mutex）顺序，会造成什么影响？**  
先执行P(mutex),对缓冲区访问上锁。然后执行P(empty)，如果缓冲区为满。生产者进入阻塞队列，切回消费者进程，但是因为缓冲区上锁，消费者无法进入缓冲区取出产品。形成死锁。  
**因此，实现互斥的P操作一定要在实现同步的P操作之后。**

#### #多生产者，多消费者问题
1. 多个生产者进程，多个消费者进程。每个生产者生产一类产品，每个消费者固定消费一类产品。
2. 每个消费者进程只固定读取特定的一个生产者生产的产品。
3. 缓冲区大小为1.
4. 其他约束条件类似生产者-消费者问题。
假定有两类生产者，两类消费者。一个缓冲区大小为1的盘子，父亲放入苹果，女儿取出苹果，母亲放入橘子，儿子取出橘子。
```c
semaphore mutex =1; //互斥访问缓冲区
semaphore apple =0;
semaphore orange =0;
semaphore plate =1; //盘子还可以放入多少水果

dad(){
  while (1) {
    //准备一个苹果
    P(plate);
    P(mutex);
    //把苹果放入盘子
    V(mutex);
    V(apple);
  }
}
mom(){
  //准备一个橘子
  P(plate);
  P(mutex);
  //把橘子放入盘子
  V(mutex);
  V(orange);
}
daughter(){
  P(apple);

  P(mutex);
  //从盘中取出苹果
  V(mutex);
  V(plate);
  //吃掉苹果
}
son(){
  P(orange);

  P(mutex);
  //从盘中取出橘子
  V(mutex);
  V(plate);
}
```

#### #3吸烟者问题
假设一个系统有三个抽烟者进程和一个供应者进程，但是要卷起并抽掉一支烟，抽烟者需要三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷起一根烟并抽掉它，并给供应者进程进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复。 
问题分析：
1.  同步：供应者和三个抽烟者有同步关系。
2. 互斥，每个抽烟者之间互斥。
3. 桌子是大小为1的缓冲区。要互斥操作。
```c
semaphore offer1=0;
semaphore offer2=0;
semaphore offer3=0;
semaphore finish=0;
int i=0;
provide(){
    while(1){
        if(i==0){
            //将组合一放入桌上
            V(offer1);
        } else if(i==1){
            //将组合二放入桌上
            V(offer2);
        }else if (i==2){
            //将组合三放入桌上
            V(offer3);
        }
        i=(i+1)%3;
        P(finfish);
    }
}
smoker1(){
    while(1){
        P(offer1);
        //从桌子上拿走组合
        //卷烟，抽掉
        V(finish);
    }
}
smoker2(){
    while(1){
        P(offer2);
        //从桌子上拿走组合
        //卷烟，抽掉
        V(finish);
    }
}
smoker3(){
    while(1){
        P(offer3);
        //从桌子上拿走组合
        //卷烟，抽掉
        V(finish);
    }
}
```
吸烟者问题知识点：
1. 可以生产多个产品的单生产者。 

#### #4读者-写者问题
问题概述：
1. 有读者，写者两组进程，共享一个文件。
2. 允许两个或以上读者进程同时访问共享数据。
3. 只允许一个写者进程写入信息。
4. 任一写者在完成操作前不允许其他读者或写者工作。
5. 写者执行写操作前，让已有的读者和写者全部退出。
问题分析：
1. 写进程和所有其他进程互斥。
2. 保证读进程能够同时访问。
```c
semaphore rw=1;
int count=0;
semaphore mutex=1;
//这个方法是读进程优先的
writer(){
    while(1){
        P(rw);
        //写文件
        V(rw);
    }
}
reader(){
    while(1){
        P(mutex);
        if(count==0){
            P(rw);
        }
        count++;
        V(mutex);
        //读文件
        P(mutex);
        count--;
        if(count==0){
            V(rw);
        }
        V(mutex);
    }
}
```
```c
semaphore rw=1;
int count=0;
semaphore mutex=1;
semaphore w=1;  //实现读写公平
writer(){
    while(1){
        P(w);
        P(rw);
        //写文件
        V(rw);
        V(w);
    }
}
reder(){
    while(1){
        P(w);
        P(mutex);
        if(count==0){
            P(rw);
        }
        count++;
        V(mutex);
        V(w);
        //读文件
        P(mutex);
        count--;
        if(count==0){
            V(rw);
        }
        V(mutex);
    }
}
```
#### #5哲学家进餐问题
圆桌上有五个哲学家，每个哲学家两边各有一根筷子。哲学家只做两件事，思考和进餐。思考不影响其他人，进餐要拿起左右两根筷子。如果筷子已经在别人手上，则等待。  
问题分析：
1. 5个哲学家进程，与左右邻居对其中间的筷子访问是互斥的。
2. 每个进程需要两个临界资源。
3. 避免死锁。
```c
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex=1;
Pi(){    //第i号哲学家进程
    do{
        P(mutex);
        P(chopstick[i])
        P(chostick((i+1)%5);
        V(mutex);
        eat;
        V(chopstick[i]);
        P(chostick((i+1)%5);
        think;
    }while(1);
}
```
### 2.3.6 管程
#### #1管程的组成
1. 局部于管程的共享数据结构说明。
2. 对该数据结构进行操作的一组过程（函数）。
3. 对局部于管程的共享数据设置初始值的语句。
4. 管程有一个名字。
#### #2管程的特征
1. 局部于管程的数据只能被局部于管程的过程所访问。
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据。
3. 每次仅允许一个进程在管程内执行某个过程。
#### #3管程的定义
管程是由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变数据和同步过程。

## 2.4死锁

### 2.4.1死锁的定义
并发环境下，各个进程在循环等待资源的现象。
死锁和饥饿的区别：
1. 死锁至少有两个或两个以上进程同时发生死锁。饥饿可能只有一个进程饥饿。
2. 发生死锁的进程一定处于阻塞态，饥饿可能是阻塞态，也可能是就绪态。
#### 死锁产生的必要条件
必须同时满足以下四个条件：
1. 互斥条件。 只有对必须互斥使用的资源才会导致死锁。
2. 不可剥夺条件。 进程所获得的资源在为使用完之前，不能由其他进程强行夺走，只能主动释放。
3. 请求和保持条件。 进程至少保持了一个资源，但又提出新的资源请求。
4. 循环等待条件。 

#### 死锁产生的原因
1. 系统资源的竞争
2. 进程推进顺序非法

#### 死锁的处理策略
1. 预防死锁。 破坏死锁产生的四个必要条件。
2. 避免死锁。 用某种方法防止系统进入不安全状态。
3. 死锁的检测和解除。 允许死锁发生，操作系统采取某种措施解除死锁。

### 2.4.2 预防死锁
#### 破坏互斥条件
（spooling技术，把独占设备逻辑上改成共享设备）。  
缺点： 并不是所有资源都可以改成共享资源。
#### 破坏不剥夺条件
方案一： 当某个请求新的资源得不到满足时，它必须立即释放所有资源，以后重新申请。  
方案二： 当某个进程想要的资源被其他进程所占用的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式要考虑优先级。
缺点： 
1. 实现复杂。
2. 释放已获得的资源可能造成前一阶段的工作失效。因此只适用于易保存和恢复状态的资源，如cpu。  
3. 增加系统开销，降低系统吞吐量。
4. 方案一可能导致饥饿。
#### 破坏请求和保持条件
采用静态分配方法。 进程在运行前一次申请完它所需要的全部资源。
缺点： 有些资源可能只需要很短的时间，如果进程整个运行期间都一直保持着所有资源，造成资源浪费，**资源利用率低** 可能导致某系进程饥饿。
#### 破坏循环等待条件
采用顺序资源分配法。首先给资源编号，规定每个进程 **必须按编号递增的顺序请求资源**，同类资源（编号相同的资源）一次性申请完。
缺点： 
1. 不方便增加新设备，可能导致重新分配编号。
2. 造成资源浪费。
3. 用户编程麻烦。

### 2.4.2死锁避免
避免死锁同样属于事先预防策略，但是不是事先采取某种限制错措施破坏死锁的必要条件，而是在资源分配过程中，防止系统进入不安全状态，避免发生死锁。  
安全序列： 如果系统按照这种序列分配资源，则每个进程都能顺利完成。  
安全状态： 只要能找出一个安全序列，系统就是安全状态，安全序列可能有多个。  
安全状态一定不会发生死锁。不安全状态可能发生死锁。  

#### 银行家算法
数据结构：
1. 最大需求矩阵Max：n个进程，m种资源。 
2. 可利用资源向量Aailable：系统还有多少可用资源。
3. 分配矩阵Allocation：系统已经分配的资源。
4. 需求矩阵Need： 每个进程还需要多少资源。
5. Need=Max-Allocation
6. 请求向量Request: 某个进程请求向量。

##### 银行家算法描述
1. 判断是否Request[j]<=Need[i,j]，如果是进入下一步，如果不是，则出错（所需资源数大于已宣布最大值）
2. 如果Request[j]<=Available[j],则下一步，如果否，尚无足够资源，进程等待。
3. ***试探着***分配资源，并修改相应的数据。
- Available=Available-Request;
- Allocation[i,j]=Allocation[i,j]+Request[j];
- Need[i,j]=Need[i,j]+Request[j];
4. 操作系统执行安全性算法，奸诈此次资源分配后，系统是否处于安全状态，安全则分配，不安全则阻塞等待。

##### 银行家算法步骤
1. 检查此次申请是否超过了之前声明的最大需求数。
2. 检查此时系统剩余的可用资源是否能满足此次需求。
3. 试探着分配，更改各数据结构。
4. 用安全性算法检查此次分配是否会导致系统进入不安全状态。

##### 安全性算法步骤
1. 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以则加入安全序列，并把该进程的持有的资源全部回收。
2. 不断重复，看是否能让所有进程都加入安全序列。

### 2.4.5死锁的检测和解除

#### 死锁检测
资源分配图  
- 两种结点，一个代表进程，一个代表资源。
- 两种边， 一个是进程请求，一个是资源分配几个资源（一条边代表一个）

**死锁定理**
#### 死锁解除
1. 资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。
2. 撤销进程法。 强制撤销部分、甚至全部死锁进程，剥夺资源。
3. 进程回退法。 让一个或多个进程回退到足以避免死锁的地步。需要系统设置还原点。

如何决定
1. 进程优先级。
2. 执行时长
3. 还要多久完成。
4. 进程持有了多少资源
5. 交互式还是批处理。 

