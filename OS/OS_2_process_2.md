### 2.3.5 经典同步问题

#### #1生产者-消费者问题
系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个数据放入缓冲区，消费者每次从缓冲区取出一个产品并使用。  
限制条件：
1. 生产者，消费者共享一个初始为空，大小为n的缓冲区。
2. 只有缓冲区没满时，生产者才能把数据放入缓冲区，否则必须等待。
3. 只有缓冲区不空时，消费者才能取出数据，否则必须等待。
4. 缓冲区是临界资源，各进程必须互斥地访问。
```c
semaphore mutex =1;  //互斥信号量，实现对缓冲区互斥。
semaphore empty =n;  // 同步信号量，确定缓冲区空间
semaphore full; =0;  //同步信号量，确定产品数量。

producer(){
  while (1) {
    //生产产品
    P(empty);
    P(mutex);
    //把产品放入缓冲区
    V(mutex);
    V(full)；
  }
}
consumer(){
  while(1){
    P(full);
    P(mutex);
    //从缓冲区取出一个产品
    V(mutex);
    V(empty);
    //使用产品
  }
}
```
如果要进行互斥操作，需要在同一进程内进行一对P，V操作。  
如果要进行同步操作，需要在两个进程实现同步关系，一个执行P，一个执行V。  
**如果调换P(empty)和P（mutex）顺序，会造成什么影响？**  
先执行P(mutex),对缓冲区访问上锁。然后执行P(empty)，如果缓冲区为满。生产者进入阻塞队列，切回消费者进程，但是因为缓冲区上锁，消费者无法进入缓冲区取出产品。形成死锁。  
**因此，实现互斥的P操作一定要在实现同步的P操作之后。**

#### #多生产者，多消费者问题
1. 多个生产者进程，多个消费者进程。每个生产者生产一类产品，每个消费者固定消费一类产品。
2. 每个消费者进程只固定读取特定的一个生产者生产的产品。
3. 缓冲区大小为1.
4. 其他约束条件类似生产者-消费者问题。
假定有两类生产者，两类消费者。一个缓冲区大小为1的盘子，父亲放入苹果，女儿取出苹果，母亲放入橘子，儿子取出橘子。
```c
semaphore mutex =1; //互斥访问缓冲区
semaphore apple =0;
semaphore orange =0;
semaphore plate =1; //盘子还可以放入多少水果

dad(){
  while (1) {
    //准备一个苹果
    P(plate);
    P(mutex);
    //把苹果放入盘子
    V(mutex);
    V(apple);
  }
}
mom(){
  //准备一个橘子
  P(plate);
  P(mutex);
  //把橘子放入盘子
  V(mutex);
  V(orange);
}
daughter(){
  P(apple);

  P(mutex);
  //从盘中取出苹果
  V(mutex);
  V(plate);
  //吃掉苹果
}
son(){
  P(orange);

  P(mutex);
  //从盘中取出橘子
  V(mutex);
  V(plate);
}
```

#### #3吸烟者问题
假设一个系统有三个抽烟者进程和一个供应者进程，但是要卷起并抽掉一支烟，抽烟者需要三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷起一根烟并抽掉它，并给供应者进程进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复。 
问题分析：
1.  同步：供应者和三个抽烟者有同步关系。
2. 互斥，每个抽烟者之间互斥。
3. 桌子是大小为1的缓冲区。要互斥操作。
```c
semaphore offer1=0;
semaphore offer2=0;
semaphore offer3=0;
semaphore finish=0;
int i=0;
provide(){
    while(1){
        if(i==0){
            //将组合一放入桌上
            V(offer1);
        } else if(i==1){
            //将组合二放入桌上
            V(offer2);
        }else if (i==2){
            //将组合三放入桌上
            V(offer3);
        }
        i=(i+1)%3;
        P(finfish);
    }
}
smoker1(){
    while(1){
        P(offer1);
        //从桌子上拿走组合
        //卷烟，抽掉
        V(finish);
    }
}
smoker2(){
    while(1){
        P(offer2);
        //从桌子上拿走组合
        //卷烟，抽掉
        V(finish);
    }
}
smoker3(){
    while(1){
        P(offer3);
        //从桌子上拿走组合
        //卷烟，抽掉
        V(finish);
    }
}
```
吸烟者问题知识点：
1. 可以生产多个产品的单生产者。 

#### #4读者-写者问题
问题概述：
1. 有读者，写者两组进程，共享一个文件。
2. 允许两个或以上读者进程同时访问共享数据。
3. 只允许一个写者进程写入信息。
4. 任一写者在完成操作前不允许其他读者或写者工作。
5. 写者执行写操作前，让已有的读者和写者全部退出。
问题分析：
1. 写进程和所有其他进程互斥。
2. 保证读进程能够同时访问。
```c
semaphore rw=1;
int count=0;
semaphore mutex=1;
//这个方法是读进程优先的
writer(){
    while(1){
        P(rw);
        //写文件
        V(rw);
    }
}
reader(){
    while(1){
        P(mutex);
        if(count==0){
            P(rw);
        }
        count++;
        V(mutex);
        //读文件
        P(mutex);
        count--;
        if(count==0){
            V(rw);
        }
        V(mutex);
    }
}
```
```c
semaphore rw=1;
int count=0;
semaphore mutex=1;
semaphore w=1;  //实现读写公平
writer(){
    while(1){
        P(w);
        P(rw);
        //写文件
        V(rw);
        V(w);
    }
}
reder(){
    while(1){
        P(w);
        P(mutex);
        if(count==0){
            P(rw);
        }
        count++;
        V(mutex);
        V(w);
        //读文件
        P(mutex);
        count--;
        if(count==0){
            V(rw);
        }
        V(mutex);
    }
}
```
#### #5哲学家进餐问题
圆桌上有五个哲学家，每个哲学家两边各有一根筷子。哲学家只做两件事，思考和进餐。思考不影响其他人，进餐要拿起左右两根筷子。如果筷子已经在别人手上，则等待。  
问题分析：
1. 5个哲学家进程，与左右邻居对其中间的筷子访问是互斥的。
2. 每个进程需要两个临界资源。
3. 避免死锁。
```c
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex=1;
Pi(){    //第i号哲学家进程
    do{
        P(mutex);
        P(chopstick[i])
        P(chostick((i+1)%5);
        V(mutex);
        eat;
        V(chopstick[i]);
        P(chostick((i+1)%5);
        think;
    }while(1);
}
```
### 2.3.6 管程
#### #1管程的组成
1. 局部于管程的共享数据结构说明。
2. 对该数据结构进行操作的一组过程（函数）。
3. 对局部于管程的共享数据设置初始值的语句。
4. 管程有一个名字。
#### #2管程的特征
1. 局部于管程的数据只能被局部于管程的过程所访问。
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据。
3. 每次仅允许一个进程在管程内执行某个过程。
#### #3管程的定义
管程是由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变数据和同步过程。

## 2.4死锁

### 2.4.1死锁的定义









