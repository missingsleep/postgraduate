### 2.3.5 经典同步问题

#### #1生产者-消费者问题
系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个数据放入缓冲区，消费者每次从缓冲区取出一个产品并使用。  
限制条件：
1. 生产者，消费者共享一个初始为空，大小为n的缓冲区。
2. 只有缓冲区没满时，生产者才能把数据放入缓冲区，否则必须等待。
3. 只有缓冲区不空时，消费者才能取出数据，否则必须等待。
4. 缓冲区是临界资源，各进程必须互斥地访问。
```c
semaphore mutex =1;  //互斥信号量，实现对缓冲区互斥。
semaphore empty =n;  // 同步信号量，确定缓冲区空间
semaphore full; =0;  //同步信号量，确定产品数量。

producer(){
  while (1) {
    //生产产品
    P(empty);
    P(mutex);
    //把产品放入缓冲区
    V(mutex);
    V(full)；
  }
}
consumer(){
  while(1){
    P(full);
    P(mutex);
    //从缓冲区取出一个产品
    V(mutex);
    V(empty);
    //使用产品
  }
}
```
如果要进行互斥操作，需要在同一进程内进行一对P，V操作。  
如果要进行同步操作，需要在两个进程实现同步关系，一个执行P，一个执行V。  
**如果调换P(empty)和P（mutex）顺序，会造成什么影响？**  
先执行P(mutex),对缓冲区访问上锁。然后执行P(empty)，如果缓冲区为满。生产者进入阻塞队列，切回消费者进程，但是因为缓冲区上锁，消费者无法进入缓冲区取出产品。形成死锁。  
**因此，实现互斥的P操作一定要在实现同步的P操作之后。**

#### #多生产者，多消费者问题
1. 多个生产者进程，多个消费者进程。每个生产者生产一类产品，每个消费者固定消费一类产品。
2. 每个消费者进程只固定读取特定的一个生产者生产的产品。
3. 缓冲区大小为1.
4. 其他约束条件类似生产者-消费者问题。
假定有两类生产者，两类消费者。一个缓冲区大小为1的盘子，父亲放入苹果，女儿取出苹果，母亲放入橘子，儿子取出橘子。
```c
semaphore mutex =1; //互斥访问缓冲区
semaphore apple =0;
semaphore orange =0;
semaphore plate =1; //盘子还可以放入多少水果

dad(){
  while (1) {
    //准备一个苹果
    P(plate);
    P(mutex);
    //把苹果放入盘子
    V(mutex);
    V(apple);
  }
}
mom(){
  //准备一个橘子
  P(plate);
  P(mutex);
  //把橘子放入盘子
  V(mutex);
  V(orange);
}
daughter(){
  P(apple);

  P(mutex);
  //从盘中取出苹果
  V(mutex);
  V(plate);
  //吃掉苹果
}
son(){
  P(orange);

  P(mutex);
  //从盘中取出橘子
  V(mutex);
  V(plate);
}
```

#### #3吸烟者问题
假设一个系统有三个抽烟者进程和一个供应者进程，但是要卷起并抽掉一支烟，抽烟者需要三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷起一根烟并抽掉它，并给供应者进程进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复。 
问题分析：
1.  同步：供应者和三个抽烟者有同步关系。
2. 互斥，每个抽烟者之间互斥。
3. 桌子是大小为1的缓冲区。要互斥操作。
```c
semaphore offer1=0;
semaphore offer2=0;
semaphore offer3=0;
semaphore finish=0;
int i=0;
provide(){
    while(1){
        if(i==0){
            //将组合一放入桌上
            V(offer1);
        } else if(i==1){
            //将组合二放入桌上
            V(offer2);
        }else if (i==2){
            //将组合三放入桌上
            V(offer3);
        }
        i=(i+1)%3;
        P(finfish);
    }
}
smoker1(){
    while(1){
        P(offer1);
        //从桌子上拿走组合
        //卷烟，抽掉
        V(finish);
    }
}
smoker2(){
    while(1){
        P(offer2);
        //从桌子上拿走组合
        //卷烟，抽掉
        V(finish);
    }
}
smoker3(){
    while(1){
        P(offer3);
        //从桌子上拿走组合
        //卷烟，抽掉
        V(finish);
    }
}
```
吸烟者问题知识点：
1. 可以生产多个产品的单生产者。 

#### #4读者-写者问题
问题概述：
1. 有读者，写者两组进程，共享一个文件。
2. 