# 进程管理
## 2.1进程与线程
### 2.1.1进程的概念和特征

#### #1进程的概念
##### （1）定义
进程是具有独立功能的程序在一个数据集合上运行的过程。  
##### （2）组成
进程映像由三部分组成：
1. 程序段（程序代码）
2. 相关数据段（程序运行中处理的数据）
3. 进程控制块（process control block）PCB
**PCB是进程存在的唯一标志**
进程是进程映像的运行过程，是系统资源分配和调度的一个基本单位。  

#### #2进程的特征
1. 动态性。进程是程序的一次执行，它有创建、活动、暂停、终止等过程。有生命周期。
2. 并发性。 多个进程实体同时存入内存，在一段时间内同时运行。
3. 独立性。 进程实体是独立运行、独立获得资源和独立接受调度的基本单位。
4. 异步性。 进程之间各自独立的，以不可预知的速度前进。
5. 结构性。 进程实体由程序段，数据段和进程控制块三部分组成。
动态性是进程最基本的特征。  

### 2.1.2进程的状态与转换
通常进程有五种状态，前三个是基本状态：
1. 运行态。 进程正在处理机上运行。
2. 就绪态。 进程获得了除处理机外一切所需资源。
3. 阻塞态。 又称等待态。进程在等待某一事件而暂停。
4. 创建态。 进程正在被创建的状态。 首先申请空白PCB，向PCB中填写管理和控制进程信息；然后系统为进程分配资源；最后转换成就绪态。
5. 结束态。 进程运行结束或要中断退出运行，先进入结束态再回收分配的资源。

#### 进程状态转换
+ 就绪态->运行态：处于就绪态的进程被调度后，获得处理机资源（分配处理机时间片），进程就切换到运行态。
+ 运行态->就绪态：运行态进程时间片用完后切换到就绪态。此外更高级进程就绪时，当前进程也会切换到就绪态，更高级进程从就绪态切换到运行态。
+ 运行态->阻塞态：进程请求某一资源的使用和分配或等待某一事件发生，它就从运行态切换到阻塞态。
+ 阻塞态->就绪态：当进程等待的事件到来，中断处理程序吧进程从阻塞态切换到就绪态。  
**进程从运行态切换到阻塞态是主动行为，从阻塞态切换到就绪态是被动行为。**  

### 2.1.3进程控制
在操作系统中，一般把进程控制用的程序段成为原语，特点是执行期间不允许中断，是不可分割的基本单位。  

#### #1进程的创建
允许一个进程创建另一个进程。  
创建者称为父进程，被创建的称为子进程。  
子进程可以继承父进程所拥有的资源。子进程撤销时，需要归还从父进程获得的资源，父进程撤销时，必须同时撤销所有的子进程。  
进程创建的过程：（创建原语）
1. 为新进程分配一个唯一的进程标识号，并申请一个空白的PCB（PCB是有限的）
2. 为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间。如果资源不足不会创建失败而是处于阻塞态，等待资源。
3. 初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。
4. 弱进程就绪队列能够接纳新进程，新进程插入就绪队列，等待被调度。  
#### #2进程的终止
引起进程终止的事件有：
1. 正常结束，表示进程的任务已完成并准备推出运行。
2. 异常结束，表示进程运行时发生某种异常事件，是程序无法继续运行。
3. 外界干预，指进程应外界请求而终止运行。   

系统终止进程过程： （撤销原语）
1. 根据被终止进程的标识符，检索PCB，从中读出该进程的状态。
2. 若被终止进程处于执行状态，立即终止该进程执行，将处理机资源分配给其他进程。
3. 若该进程还有子孙进程，子应将其所有子孙进程终止。
4.  将该进程所拥有的全部资源，归还给父进程或操作系统。
5. 将该PCB从所在队列删除。
#### #3进程的阻塞和唤醒
正在执行的进程，由于期待的某些事件未发生，由系统自动执行阻塞原语（Block），从运行态切换到阻塞态。
阻塞原语执行过程：
1. 找到将要被阻塞进程的标识号对应的PCB
2. 若进程为运行态，则保护现场，将其状态转为阻塞态，停止运行
3. 把该PCB插入相应事件的等待队列，将处理剂资源调度给其他就绪进程。

当阻塞进程期待的事件发生了，由有关进程（等待的事件相关进程）执行唤醒原语（Wakeup）将该进程唤醒。
唤醒原语执行过程：
1. 找出要唤醒进程的PCB
2. 将其从等待队列移出，转为就绪态。
3. 把该PCB插入就绪队列。

BLock原语和Wakeup原语是一对作用相反的原语，必须成对使用。  
**BLock原语是被阻塞进程自我调用，Wakeup原语是由一个相关进程调用实现的。**
#### #4进程切换
进程切换是指从运行一个进程切换到运行另一个进程。
进程切换过程：
1. 保存处理机上下文，包括程序计数器和其他寄存器。
2. 更新PCB信息。
3. 把进程的PCB移入相应的队列，如就绪、某时间阻塞等队列。
4. 选择另一个进程执行，并更新其PCB。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。

### 2.1.4进程的组织
进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位。由三部分组成，最核心的是进程控制块（PCB）
#### #1进程控制块（PCB）
进程创建时，操作系统为它新建一个PCB，PCB常驻内存，进程结束时，系统收回其PCB。
**PCB是进程实体的一部分，PCB是进程存在的唯一标志**
PCB构成：
1. 进程描述信息。 进程标识符（PID），所属用户标识符（UID）。每个进程都有一个唯一的标识号。
2. 进程控制和管理信息。进程当前状态：描述进程的状态信息。进程优先级：描述进程抢占处理机的优先级。
3. 资源分配清单。 描述相关内存地址空间和虚拟地址空间状态。
4. 处理机相关信息。处理机中各种寄存器的值，也就是进程从运行态切换到就绪态时的运行环境。  
#### #2程序段
程序段就是被进程调度程序调度到CPU执行的程序代码段。  
程序可被多个进程共享，也就是多个进程可以运行同一个程序。  
#### #3数据段
进程对应的程序加工处理的原始数据，程序执行过程中的中间或最终结果都是数据段。

### 2.1.5进程的通信
进程通信是指进程之间的信息交换。  
PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的方式。
#### #1共享存储
在通信的进程之间存在一块可直接访问的共享空间。两个进程通过对这片共享空间写/读操作实现信息交换。  
共享存储分为两种方式：
1. 低级方式的共享是基于数据结构的共享。
2. 高级的共享则是基于存储区的共享。
#### #2消息传递
进程间的数据交换是以格式化的消息（Message）为单位的。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。
1. 直接通信方式。 发送进程直接把消息发送给接收进程，将它挂在接收进程的消息缓冲队列上，接受进程从消息缓冲队列中取得信息。
2. 间接通信方式。 发送进程把消息发送到中间实体，接收进程从中间实体取得消息。
#### #3管道通信
管道是指用于连接一个读进程和一个写进程以实现它们之间的通信的一个共享文件，又名pipe文件。  
为了协调双方的通信，管道机制必须提供以下三方面协调能力：互斥、同步和确定对方的存在。  
管道通信关键点：
1. 从管道读数据是一次性操作，数据一旦被读取，他就从管道中被抛弃。
2. 管道只能采用半双工通信，即某一时刻只能单向传输，要互相传输消息需要两个管道。
3. 管道只允许一边写入，一边读出。写的时候不允许读，管道非空，不允许写。  

### 2.1.6线程概念和多线程模型
#### #1线程的基本概念
引入线程的目的是为了减小程序在并发执行时的时空开销，提高并发性能。
线程特点：
1. 线程是一个基本的CPU执行单元，也是程序执行流的最小单元。
2. 拥有线程ID，程序计数器，寄存器集合和堆栈组成。
3. 线程是进程中的一个实体，线程自己不拥有系统资源，但是线程可与同一进程内其他线程共享进程的全部资源。
4. 一个线程可以创建和撤销另一个线程。
5. 同一进程内线程可以并发执行。

**进程为除CPU外的系统资源分配单元，线程为处理机的分配单元。**  
同一进程内线程切换只需要很小的时空开销。  
#### #2线程与进程的比较
1. 调度。有线程的操作系统中，线程切换不会引起进程切换。
2. 拥有资源。 进程是拥有资源的基本单位，线程不拥有系统资源，线程可以访问其隶属进程的系统资源。
3. 并发性。 引入线程的操作系统，多个线程之间也可以并发执行，提升并发性，提高系统的吞吐量。
4. 系统开销。 创建和撤销进程的系统开销远大于线程。进程切换时涉及当前CPU环境，线程切换时，只需要保存和设置少量寄存器内容。同时，线程通信容易实现，甚至不需要操作系统的干预。
5. 地址空间和其他资源。 进程的地址空间之间相互独立，统一进程的各线程间共享进程的资源。某进程内的线程对其他进程不可见。
6. 通信方面。 进程间通信需要进程同步和互斥手段，线程间可以直接读写进程数据段来通信。
#### #3线程的属性
多线程操作系统将线程作为独立运行（或调度）的基本单位，如果进程处于运行态，是指进程中的某线程正在执行。  
线程主要属性：
1. 线程都应有一个唯一的标识符和一个线程控制块，线程控制块纪录了线程执行的寄存器和栈等现场状态。
2. 不同线程可以执行相同的程序。即同一个服务被不同用户调用时，产生多个线程。
3. 统一进程内各个线程共享该进程所拥有的资源。
4. 线程是处理机的独立调度单温，多个线程可以并发执行。
5. 线程也通过进程一样有阻塞态，就绪态和运行态等变化。  
#### #4线程的实现方式
线程的实现分为两类：用户级线程（User-Level thread,ULT）和内核级线程(Kernel-Level Thread,KLT)。内核级线程又称为内核支持的线程。  
1. 用户级线程由应用程序完成线程管理的所有工作，内核意识不到线程的存在。应用程序可以通过线程库实现多线程程序。
2. 内核级线程管理工作由内核完成。

#### #5多线程模型
有些系统同时支持用户线程和内核线程，由此产生多线程模型。
1. 多对一模型。多个用户线程映射到一个内核线程，线程管理在用户空间完成。  
+ 优点：线程管理在用户空间，效率高。  
+ 缺点：一个线程在使用内核服务室被阻塞，整个进程都会阻塞；多个线程不能并行地运行在多处理机上。
2. 一对一模型。 将每个用户线程映射到一个内核线程。
+ 优点：当一个线程阻塞时，允许另一个线程继续执行，并发能力强。
+ 缺点： 创建线程的开销大，会影响应用程序的性能。
3. 多对多模型。 n个用户级线程映射到m个内核级线程 m $\le$n
+ 特点：上面两个综合。

***
### 2.1难点总结
1. 进度的优先级分为静态优先级和动态优先级。动态优先级根据情况调整优先级。
2. 发生死锁时，没有进程为运行态。
3. 进程的封闭性是指进程执行的结果只取决于进程本身，不受外界影响。如果失去进程封闭性，不同速度下执行结果不同。
4. 进程在多程序环境中不等同于完整程序。
5. 全局赋值变量写在进程的正文段。
6. 同一程序多次创建，运行在不同数据集上，形成不同的进程。
7. 同一系统线程被不同的进程调用，他们是同一线程。
8. 父进程创建子进程后，父进程与子进程可以并发执行。主程序调用子程序后，主程序停留在调用点，子程序运行。
9. 每个进程都有自己的独立地址空间。为了保证多个进程能够彼此互不干扰地共享物理内存，系统限制每个进程只能访问自己的地址空间。
10. 多线程是指在一个程序中可以定义多个线程并同时运行它们，每个线程可以执行不同任务。  

***
## 2.2处理机调度

### 2.2.1调度的概念
#### #1调度的基本概念
在多道程序系统中，进程数量远多于处理机个数。处理机调度是对处理机进行分配，即从就绪队列中按照一定算法选择一个进程运行。  
#### #2调度的层次
##### （1）作业调度
又称高级调度。主要任务是从外存处于后备状态的作业中挑选一个作业，给它分配系统资源。  
**作业调度就是内存与辅存之间的调度，对于每个作业只调入一次，掉出一次。**  
##### （2）中级调度
又称内存调度。作用是提高内存利用率和系统吞吐量。将暂时不能运行的进程调至外存等待，此时进程状态是挂起态。当需要时再调入内存，修改为就绪态。
**挂起态的进程PCB依然在内存中**  
##### (3)进程调度
又称低级调度。按照一定策略从就绪队列中选取一个进程，将处理机分配给它。
**进程调度是操作系统中最基本的一种调度** 进程调度的频率很高。

#### #3三级调度的联系
1. 作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起。
2. 作业调度次数少，进程调度频率最高。
3. 进程调度是最基本的，不可或缺的。

### 2.2.2调度的时机、切换与过程
进程调度和切换程序是操作系统内核程序。
三步：
1. 请求调度事件发生
2. 运行调度程序
3. 调度了新的进程后，才会进行进程的切换  

不能进行进程的调度与切换情况：
1. **在处理中断** 过程中，不会做进程切换。中断处理是系统工作的一部分，逻辑上不属于某一进程，不应该被剥夺处理机资源。
2. **进程在操作系统内核程序临界区**
3. **原语操作** 中。  

上述过程中不能马上进行调度和切换，直到上述过程结束后才进行相应的调度和切换。  
应该进行调度和切换的情况：
1. 发生引起调度条件且当前进程无法继续进行时。
2. 中断处理结束后，即可马上进行调度与切换。剥夺方式调度。

### 2.2.3进程调度方式
1. 非剥夺调度方式，又称非抢占方式。 当前处理机正在执行一个进程时，不会切换进程。只有进程完成或者进程阻塞才会切换。
2. 剥夺调度方式，又称抢占方式。当一个进程在处理机上执行时，若有个更重要或紧迫的进程需要处理机，则立即暂停当前进程，将处理机分配给更重要的进程。  

**采用剥夺式调度，提高系统吞吐率和响应效率。**  

### 2.2.4调度的基本准则
为了比较处理机调度算法的性能，提出了以下评价准则：
1. CPU利用率。 尽可能使CPU保持“忙”状态。
2. 系统吞吐量。 表示单位时间内CPU完成作业的数量。长作业需要消耗更多的处理机时间，因此会降低系统吞吐量。
3. 周转时间。 周转时间是从作业提交到作业完成需要的时间。
+ 平均周转时间=（作业1周转时间+作业2周转时间+...+作业n周转时间）/n
+ 带权周转时间= $\frac{作业周转时间}{作业实际运行时间}$  
+ 平均带权周转时间为多个作业带权周转时间的平均值。
4. 等待时间。等待时间是进程处于等处理机状态的时间之和。处理机调度算法只看作业处于就绪队列中等待所花的时间。
5. 响应时间。 响应时间是指用户提交请求到系统首次山城响应所用的时间。

### 2.2.5典型的调度算法
#### #1先来先服务（FCFS）算法
FCFS算法是最简单的调度算法。它既可以用于作业调度，又可用于进程调度。  
FCFS调度算法每次从就绪队列中选择最先进入队列的进程。知道完成或因某种原因阻塞时才释放处理机。
+ FCFS调度算法属于不可剥夺算法。
+ 对长作业比较有利，对短作业不利（相对SJF和高响应）
+ 有利于CPU繁忙型作业，不利于I/O繁忙型作业

#### #2短作业有限（SJF）调度算法
短进程优先（SPF）从就绪队列中选择一个预估运行时间最短的进程。
SJF调度算法缺点 ：
1. 对长作业不利。导致长作业不被调度（饥饿）
2. 没有考虑作业的紧迫程度
3. 调度是根据预估的作业运行时间，并不一定是真正的运行时间。

#### #3优先级调度算法
优先权调度算法即可用于作业，也可以用于进程调度。  
选择优先级高的进程，分配处理机。  
1. 非剥夺式优先级调度算法。 等待当前进程运行结束才调度更高优先级进程。
2. 剥夺式优先级调度算法。 当一个优先级更高的进程进入就绪队列时，暂停当前进程，将处理机分配给优先级更高的进程。

优先级分类：  
1. 静态优先级。 优先级在创建时确定。之后保持不变。根据：进程类型，进程对资源的要求，就绪进程等待CPU时长。  
2. 动态优先级。 在进程运行过程中，根据进程情况变化调整优先级。根据：进程占用CPU时间的长短，就绪进程等待CPU时间的长短。

一般优先级顺序：
1. 系统进程>用户进程。
2. 交互型进程>非交互型进程。 前台进程>后台进程。
3. I/O型进程>计算型进程。 I/O型进程指更频繁使用I/O设备的进程。I/O设备处理速度要比CPU慢。  

#### #4高响应比优先调度算法（非抢占）
高响应比优先调度算法主要用于作业调度。计算响应比，响应比越高越优先。
+ 响应比= $\frac{等待时间+要求服务时间}{要求服务时间}$
1. 作业等待时间相同时，要求服务时间越短，响应比越高。
2. 要求服务时间相同时，等待时间越长，响应比越高。
3. 长作业的响应比可以随着等待时间增加而提高，克服了饥饿状态，兼顾长作业。
#### #5时间片轮转调度算法（抢占式）（RR）
时间片轮转调度算法主要适用于分时系统。   
现根据先来先服务原则，但是只能运行一个时间片，如100ms，时间片用完后，即使没有完成运行也要释放给下一个就绪的进程，未完成的进程重新进入就绪队列。  
**时间片划分的过大，会导致所有进程都在一个时间片内完成，算法变成FCFS算法。如果时间片过小，进程切换频繁，处理机开销增大。**  
时间片长短的确定因素有：系统的响应时间，就绪队列中的进程数目，系统的处理能力。  
#### #6多级反馈队列调度算法。
+ 抢占式进程调度算法。  
算法规则：
1. 设置多级就绪队列，优先级从高到低，时间片从小到大。
2. 新进程进入第一级队列，按照FCFS原则排队等待分配时间片，时间片用完还未结束进入下一级队尾，若已经在最下级队列，分配到当前队尾。
3. 只有第k级队列为空，才会为k+1级队列分配时间片。
4. 当一个进程正在运行，上级队列有进程进入，当前运行进程被抢占，回到当前队列队尾（**注意，不会到下一级队尾。**），优先运行上级队列的进程。
被抢占的进程下次运行也会运行一个完整的时间片。  

**可能导致饥饿**  
优点：
1. 各进程相对公平。（FCFS优点）
2. 每个新到达的进程可以很快得到响应（RR优点）
3. 不必预估进程运行时间（避免了优先级调度算法缺点）
***
### 2.2难点总结
1. FCFS更有利于CPU繁忙型作业，CPU繁忙型作业更接近长作业。
2. 优先级调度算法显著优点是题高系统资源利用率。（I/O型作业优先于CPU繁忙型作业）
